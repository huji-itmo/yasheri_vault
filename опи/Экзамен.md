## 1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ. 

Жизненный цикл ПО: 

- Разработка требований (заказчик, программисты)
- Анализ
- Проектирование архитектуры
- Разработка
- Тестирование
- Внедрение в эксплуатацию
- Эксплуатация (багфиксы, поддержка пользователей, обновления)
- Вывод из эксплуатации
	- Сохранность накопленных файлов
	- Миграция на новое ПО

Группы ЖЦ ПО: 

1. Процесс согласования (2)
2. Процесс организационного обеспечения (5)
3. Процессы проекта (7)
4. Технологические процессы (11)
5. Процесс реализации программного средства (7)
6. Процесс поддержки ПС (8)
7. Процесс повторного использования ПС

## 2. Модели ЖЦ (последовательная, инкрементная, эволюционная)

#### Последовательная 
-  A.k.a. однократная, waterfall
-  Определены все требования, один этап разработки
-  Один последовательный проход
-  Получившиеся результаты окончательны и, как правило, не подлежат пересмотру

#### Инкрементнеая
- Определены не все требования
- Разрабатывается прототип, который с течением времени развивается

###### Сравнение стратегий
|Стратегия разработки|В начале процесса определены все требования?|Множество циклов разработки?|Промежуточное ПО распространяется?|
|---|----|----|---|
|Последовательная|Да|Нет|Нет|
|Инкрементная|Да|Да|Maybe|
|Эволюционная|Нет|Да|Да|

## 3. Водопадная (каскадная) модель
![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcgj2PIgMq0q2Jhji2fL1A6NOf8alPM-GHervvvjrMAcLqkf2DINsZiu5lkalI72crfZSFaSRiID0-zVDM9NfU0Zq0DtSb2a7l_FH7RBAkbzG54EILaX0k9zfK2l-7E2WpghTykpf4mc_9QPT-h-3xhkCQY?key=1pD2kcEQ8Lrk26WoBNVmmQ)


- Разработана в 60-х
- Описана ройсом в 70-х

**Суть** в том, что есть 7 фаз раработки ПО, которые идут друг за другом только, и только в этом порядке и между ними есть итерации:

1. Сбор требований к системе
2. Сбор требований к ПО
3. Анализ требований
4. Проектирование дизайна ПО
5. Кодирование
6. Тестирование
7. Эксплуатация

- Можно откатиться к предыдущей фазе, но это сложно и не особо предусмотрено, так как потенциально это может привести к двухкратному росту сроков и стоимости разработки

|Плюсы|Минусы|
|---|---|
|Хорошие показатели по срокам разработки и надежности при решении отдельных задач|Неприменимость к большим и сложным проектам из-за невозможности принять изменения требований к системе в течение длительного проектирования|
|Автоматизация отдельных несвязных задач|Позднее тестирование|

## 4. Методология Ройса
Водопад, но с дополнительными шагами
 
 1. Предварительный дизайн - между программными требованиями и анализом
	 - Программисты и аналитики не допускаются
	 - На этом этапе предполагается спроектировать, определить и создать модель обработки данных, а так же создать документ-обзор системы
2. Написание документации для всей системы
	- Требования к системе
	- Спецификация предварительного дизайна
	- Спецификация дизайна интерфейсов
	- Финальная спецификация дизайна системы
	- План тестирования
	- Инструкция пользовательской эксплуатации
3. Параллельная разработка тестовой версии с укороченным временем разработки для анализа характеристик ПО
4. Тестирование с привлечением независимых экспертов
	- Наиболее рисковая фаза с точки зрения денег и сроков
5. Несколько этапов подключения пользователей
	- Предварительный
	- Критический
	- Финальный просмотр


## 5. Традиционная V-chart model J. Munson, B.Boehm
![[pictures/vchart.png]]
Та же последовательность действий, что и в водопаде, но ее изогнули в форме V, сопоставив с почти каждой фазой из каскадной модели соответствующее тестирования

Определяются следующие этапы:
1. Сбор требований к системе $\leftrightarrow$ Использование и поддержка  
2. Сбор требований к ПО $\leftrightarrow$ Установка системы в конечном окружении  
3. Дизайн продукта $\leftrightarrow$ Приемочное тестирование  
4. Детализация дизайна $\leftrightarrow$ Системное и интеграционное тестирование  
5. Кодирование $\leftrightarrow$ Юнит-тестирование  

## 6. Многопроходная модель (Incremental model)
**Частный случай V-chart модели**

Параллельная разработка частей продукта, а в последствии интегрирование воедино
- На этапе разработки происходит вместо одного этапа несколько, каждый включает в себя
	- Детальное проектирование
	- Кодирование
	- Интеграция протот

Снижение стоимости внесения изменений

Возможность использования частично разработанной системы

Имеет тенденцию к устареванию, деградации
- Соответственно требует рефакторинга с течением времени

При параллельной разработке несколькими командами требует стабильного API

Из-за высокой скорости изменений поддерживать документацию в больших проектах становится достаточно сложно

Из-за всех факторов, сложно оценивать стоимость разработки ПО

## 7. Модель прототипирования (80-е)
![[pictures/Прототипирование.png]]  
#### Суть
##### Фазы:
1. Планирование
- Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
- Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение

2. Пользовательское проектирование
- Пользователи взаимодействуют с системными аналитиками 
- Разрабатывают модели и прототипы
- Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованием

3. Конструирование
- На этом этапе происходит разработка программ и приложений
- Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов

4. Переключение
- Конверсия данных
- Тестирование
- Переход на новую систему
- Тренировку пользователей

##### Позволяет обеспечить:
- Быстроту продвижения програмнного продукта на рынок
- Интерфейс, устраивающий пользователя
-  Легкую адаптируемость проекта к изменяющимся требованиям
- Простоту развития функциональности системы

## 8. RAD методология
![[pictures/RAD.png]]

RAD - Rapid Application Dev Model - Быстрая разработка приложение

Порождена IBM в 80-х, обнародована в 1991
Разновидность инкрементной модели
Пользователь принимает непосредственное участие в процессе разработки
Временные рамки одного цикла **жестко** ограничены

#### Суть

##### Фазы
1. Планирование
- Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
-  Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение

2. Пользовательское проектирование
- Пользователи взаимодействуют с системными аналитиками
- Разрабатывают модели и прототипы
- Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованиям

3. Конструирование
- На этом этапе происходит разработка программ и приложений 
- Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов

4. Переключение
- Конверсию данных
- Тестирование
- Переход на новую систему
- Тренировку пользователей

##### Позволяет обеспечить
- Быстроту продвижения програмнного продукта на рынок
- Интерфейс, устраивающий пользователя
- Легкую адаптируемость проекта к изменяющимся требованиям
- Простоту развития функциональности системы

## 9. Спиральная модель
По сути - это совмещение прототипной модели + куча тестирования из V-chart модели

Особое внимание уделяется управлению рисками
- Вследствие, специфический анализ на каждой итерации

Каждый виток спирали - одна фаза разработки продукта, которая предназначена для разработки очередной версии ПО или прототипа

На разных фазах спирали разрабатываются основные концепции ПО

|Достоинства|Недостатки|
|---|---|
|Изменения - неотъемлимая часть разработки|Разработка может оказаться затратной|
|Особое внимание уделяется управлению рисками|Не подходит для маленьких проектов|


## 10. UML Диаграммы: Структурные и поведенческие

Основное значение - графическое представление различных аспектов разработки ПО

### UML
Графический язык моделирования общего назначения
Предназначен для:
- Спецификации
- Визуализации
- Проектированию и документированию артефактов

UML Диаграммы делятся на

##### Структурные
- Доменные модели
- Диаграммы развертывания

Нужны для 
- Статического описания системы
- Демонстрации архитектуры, конфигурации, специфических элементов предметной области

##### Поведенческие
- Диаграммы прецедентов использования 
	- Use-case диаграммы
	- Описывают высокоуровневые требования к системе
- Диаграммы последовательностей
	- Описывают последовательность алгоритма
- Диаграммы состояний
	- Описывают состояние системы

Представляют собой динамическую картину действий, происходящих в системе

##  11. UML: Use-case модель 
Поведенческая диаграмма

Отображает динамическое поведение в UML

Моделирует функциональность системы с использованием участников/прецедентов/других важнейших объектов

**Actors** (акторы) - люди/организации, которые работают под определенными ролями внутри системы

**Use-case** - прецедент использования

**Association** - ассоциация, использование

**Include** - включение
- Организует иерархию прецедентов и позволяет включать одну общую деятельность в несколько Use-Case'ов

**Extend** - точка расширения функционала
- Указывает расширение от базового функционала

**Generalization** - обобщение
**System Boundary** - границы системы

## 12. UML: Диаграмма классов

Структурная диаграмма

- Представляет модель **статической структуры** программной системы
- Используется в **ООП** — терминология классов
- Отражает:
	- Взаимосвязи между сущностями предметной области (f.e. объекты и подсистемы)
	- Внутреннюю структуру объектов (f.e. поля, методы)
	- Типы отношений (наследование, реализация интерфейсов)
- Не включает информацию о **временных аспектах**
- Показывает **реализованную предметную область** в первом приближении

## 13. UML: Диаграмма последовательностей

Поведенческая диаграмма

- A.k.a. диаграмма конечных автоматов
- Отображает модель **конечных автоматов**
- Представляет собой набор **состояний и условий переходов** между ними

## 14. UML: Диаграмма размещения

Структурная диаграмма

- Отображает **физическую архитектуру** размещения ПО
- Описывает процесс **развертывания артефактов** по узлам

f.e.:

- Диаграмма с изображением серверной машины, на которой:
	- Крутится веб-сервер
	- Веб-сервер запускает JVM
	- В JVM работает микросервис
	- Отдельно изображена пользовательская машина с браузером

## 15. *UP методологии (90-е). RUP: основы процесса

- RUP — частный пример \*UP, основан на OOSE + OMT + метод Буча
- Инкрементно-эволюционный процесс
- Разработка разбита на **4 фазы**:
	1. Inception / Начало
	2. Elaboration / Проектирование
	3. Construction / Построение
	4. Transition / Внедрение
- Каждая фаза заканчивается **вехой** (milestone)
- Все роли явно описаны (около 30)
	- Роль = группа обязанностей одного участника
	- У каждой роли есть:
		- Набор деятельностей
		- Входы/выходы в виде артефактов (диаграммы, документы, код)
- Все процессы в RUP связаны между собой и **подробно описаны**
- Сам RUP — это HTML-энциклопедия, все элементы связаны гиперссылками

## 16. RUP: Фаза «Начало»

**Цели:**

1. Определить границы/области применения проекта
2. Описать основные сценарии использования
3. Предложить технологическое решение
4. Рассчитать стоимость и составить график работ
5. Оценить риски
6. Подготовить окружение

**Веха: Lifecycle Objectives**

- Оценка сроков
- Первоначальная стоимость
- Требования
- Приоритеты
- Технологии
- Стратегии смягчения рисков

## 17. RUP: Фаза «Проектирование»

**Цели:**

1. Финализировать архитектуру системы
2. Разработать архитектурные прототипы
3. Проверить стабильность архитектуры, планов и рисков

**Веха: Lifecycle Architecture**

- Требования, архитектура стабильны?
- Есть критерии тестирования прототипов?
- Тестирование прошло успешно?
- Планы разработки приемлемы по стоимости?
- Расходы соответствуют бюджету?
- Проект подтвержден всеми заинтересованными сторонами?

## 18. RUP: Фаза «Построение»

**Цели:**

1. Эффективно реализовать ПО
2. Провести итерации: анализ → проектирование → код → тест
3. Создать релизы (альфа, бета…)
4. Подготовить продукт к развертыванию

**Веха: Initial Operational Capability**

- Продукт стабилен для передачи заказчику?
- Готова принимающая сторона?
- Стоимость соответствует ожиданиям?

## 19. RUP: Фаза «Внедрение»

**Цели:**

1. Развернуть систему и БД на целевой платформе
2. Обучить пользователей
3. Запустить маркетинг, продажи
4. Отладить сбои, выкатить хотфиксы
5. Убедиться в самодостаточности пользователей
6. Провести анализ соответствия ожиданиям

**Веха: Release**

- Пользователи удовлетворены?
- Финальная стоимость приемлема?

## 20. Манифест Agile (2001)

4 ценности:
1. Люди и взаимодействие > процессов и инструментов
2. Работающий продукт > исчерпывающей документации
3. Сотрудничество с заказчиком > согласованного контракта
4. Готовность к изменениям > следования плану

## 21. Scrum

- **Бэклог** — основной артефакт
	- Продукт-бэклог: бизнес-требования
	- Спринт-бэклог: технические детали
- **Спринт** — итерация 1–4 недели
	- В конце — демонстрация заказчику
	- Каждые несколько спринтов — **ретроспектива**
	- Каждый день — **дейлик** (скрам-митинг)
		- Что сделано
		- Что планируется
- **Команда**: 3–10 человек
- **Роли**:
	- Продакт овнер
		- Формирует приоритеты бэклога
	- Скрам-мастер
		- Организует скрам-митинги
		- Планирует спринты
		- Разрешает конфликты

**Плюсы:**

- Простота
- Минимум бюрократии
- Максимум ценности

## 22. Disciplined Agile 2.X (2013)

- Гибрид RUP + Scrum
- Использует **инкрементальную модель** со спринтами

#### Из RUP:
- Фазы: Начало / Построение / Внедрение
- Описание ролей

#### Из Scrum:
- Спринты

### Новое в DAD:
- Архитектурное управление
- Переиспользование кода
- Управление персоналом
- Постоянное улучшение процесса

## 23. Требования. Иерархия требований

- Требование = описание того, что должно быть реализовано
- Не говорит **как** реализовать
- Не должно быть разночтений
- Документируются в **SRS**

### Иерархия:

1. Потребности (пользователь)
	- "Мне нужна сковорода, на которой не будет пригорать"
2. Функции (аналитик)
	- "Антипригарное покрытие, термоизолированная ручка"
3. Требования к ПО
	- "Диаметр 25см, бортики 5см, алюминиевый сплав АК7П"

## 24. Свойства и типы требований (FURPS+)

Используется в RUP

### Свойства требований:

- Корректность
- Однозначность
- Полнота
- Непротиворечивость
- Приоритизация
- Проверяемость
- Модифицируемость
- Отслеживаемость

### Типы требований:

- **F** — Functional (функциональные)
- **U** — Usability (удобство использования)
- **R** — Reliability (надежность)
- **P** — Performance (производительность)
- **S** — Supportability (поддержка)
- **+** — прочее:
	- Ограничения проектирования
	- Интерфейсы
	- Физические требования


## 25. Формулирование требований. Функциональные требования

Формат записи:
`<id> <система> должна / shall <требование>`

Функциональные требования — описывают **что система должна делать**.
### Примеры:
- Feature sets
	- Наборы функциональности
- Capabilities
	- Возможности системы
- Security
	- Требования к безопасности

## 26. Требования к удобству использования и надежности (Usability & Reliability)

### Usability (удобство использования)

1. Human Factors
	- Учет особенностей пользователей
		- e.g. плохое зрение, слух
2. Aesthetics
	- Эстетические требования (e.g. брендбук, оформление интерфейса)
3. Consistency in UI
	- Согласованность элементов пользовательского интерфейса
4. Online и context-sensitive help
	- Требования к справке:
		- Онлайн-доступ
		- Контекстная подсказка
5. Wizards и Agents
	- Программы, повышающие удобство:
		- Wizard — пошаговые мастера установки (куда ставить, ярлык, uninstaller)
		-  Agents — TODO: не понял что это, нужно уточнить 
6. User Documentation
	- Требования к документации для конечных пользователей
7. Training Materials
	- Учебные материалы (видео, презентации, интерактивные мануалы)

### Reliability (надежность)

1. Frequency and severity of failure
	- Частота и серьезность отказов
2. Recoverability
	- Способность системы **восстанавливаться** в случае отказа
3. Predictability
	- Предсказуемость поведения системы
4. Availability
	- Готовность к выполнению задач в нужный момент времени
5. Accuracy
	- Точность выполнения операций
6. MTBF (Mean Time Between Failures)
	- Среднее время между отказами
## 27. Требования к производительности и поддерживаемости.


Производительность определяются
- Speed — скорость решения задач
- Efficiency — эффективность
- Availability — готовность системы к решению задач
- Throughput — пропускная способность
- Response time — время отклика
- Recovery time — время восстановления
- Resource usage — использование системных (и других) ресурсов
Поддерживаемость определяются
- Extensibility — расширяемость
- Adaptability — адаптируемость
- Maintainability — поддерживаемость
- Compatibility — совместимость
- Configurability — способность задавать конкретную конфигурацию
- Serviceability — возможность проведения профилактики и обслуживания
- Installability — требования к установке на разные системы
- Localizability — локализуемость для разных языков и географических регионов.
## 28. Атрибуты требований.

1. Приоритет - MoSCoW
	1. MUST have
		- Фундаментальные для системы требования
	2. Should have
		- Важные
	3. Could have
		- Потенциально возможные, улучшающие
		- e.g. пользовательское соглашение
	4. Won't have
		- Возможно в следующей версии
2. Статус
	1. Предложенные
	2. Одобренные
	3. Отклоненные
	4. Включенные
3. Трудоемкость
	1. Человеко-часы
	2. Функциональные точки
	3. Use-case points
	4. Попугаи
		1. Один попуг - это некое эталонное функциональное требование, которое выполняется средним человеком в команде
		2. Время, потраченное на данную работу принимается за одного попуга
		3. Все остальные требования отсчитываются относительно эталонного попугая
4. Риск
5. Стабильность
	1. Высокая
	2. Средняя
	3. Низкая
6. Целевая версия
	1. "Когда включим в продукт?"

## 29. Описание прецедента.

Прецеденты/cases могут быть описаны в виде сценариев/user story

В дальнейшем разработчики зачастую анализируют не требования, а сценарии

| Прецедент             | Описание                                           |
| --------------------- | -------------------------------------------------- |
| ID                    | Номер                                              |
| Краткое описание      | Пользователь хочет просмотреть новостную статью    |
| Главные акторы        | Пользователь                                       |
| Второстепенные акторы | Опциональны (в данном случае нет)                  |
| Предусловия           | Пользователь увидел интересующую статью            |
| Основной поток        | Пользователь переходит на одну из возможных статей |
| Альтернативный поток  | Опционален (отсутствует в данном случае)           |
| Постусловия           | Система показывает пользователю новостную статью   |

## 30. Риски. Типы Рисков.


Риск - это
 - Потенциально опасный для проекта фактор
 - Влияние неопределенности на цели
 - Сочетание вероятности события и его (негативных) последствий

Типы рисков:
1. Прямые
	1. Можем управлять, контролировать риск
2. Непрямые
    -  не можем((

Типы рисков:
1. Ресурсные
	- Организационные, финансовые, люди, время
	- Управляемые риски, так как возможно изменение выделяемых ресурсов
2. Бизнес-риски
    - Конкуренция, подрядчики, убыточность решения
    - Сложно поддается управлению со стороны разработчиков
3. Технические риски
    - Компетенции разработчиков в применяемых технологиях
4. Политические риски
	 - Сферы влияния менеджеров
	 - 
5. Форс-мажор
    - [фр.](https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%B0%D0%BD%D1%86%D1%83%D0%B7%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Французский язык") force majeure — «_высшая сила_»
    - e.g. стихийные бедствия, война, изменение законодательства)) и т.д.


## 31. Управления рисками. Деятельности, связанные с оценкой.

- Оценка (assesment) риска
	 - Идентификация риска
		 - ![[pictures/Дерево идентификации рисков.png]]
	 - Анализ риска
		 - Можно по разному анализировать (стоимостной, сетевой, качественных факторов), но есть два основных параметра риска:
			 1. Вероятность риска
			 2. Масштаб (магнитуда) потерь
		 - Задаются в разных величинах и очень субъективны
	 - Приоритизация риска
		 - После анализа необходимо вычислить экспозицию риска (Risk Exposure): $RE=Prob(UO)*Loss(UO)$, то есть произведение вероятности наступления риска на величины денежных потерь
		 - После этого состается документ "Топ-10 рисков"
			 - Этот док необходимо постоянно обновлять по мере продвижения разработки
## 32. Управления рисками. Деятельности, связанные с контролем и управлением.

Контроль и управление риском:
- Планирование управления/реакции на риски
	- Реорганизация проекта чтобы избежать наступления рисков
		- e.g. повышение квалификации сотрудников/нанимание новых образованных людей
	- Перенос риска
		- на кого-то))
		- e.g. обвинить клиента в недостаточном финансировании и сказать "нет денег - нет работ" и теперь уже риск того, что ПО не выйдет висит на клиенте 
	- Сокращение вероятности риска
	- Прием риска
		- Продолжать жить с риском, постоянно осуществляя мониторинг
- Мониторинг рисков
	- Контроль топ-10 рисков
	- Переоценка рисков
	- Автоматизированные системы
		- e.g. числовые параметры, сбор данных с жиры и VCS (git)
- Разрешения неопределенностей, связанных с рисками
	- Прототипирование системы
	- Моделирование и симуляция
	- Различные индикаторы
	- Аналитическая работа
	- Подбор персонала
## 33. Изменение. Общая модель управления изменениями.

**Изменение** - контролируемое, журналируемое обновление системы

Атрибуты изменения:
1. ID
2. Дата
3. Ответственный
4. Описание
5. Журнал изменений
6. т.д.

Управлению изменениями подлежат:
1. Требование новой функциональности
2. Нефункциональное требование
3. Исправление дефектов
4. Другие артефакты архитектуры, анализа, дизайна
5. т.д.

Из-за того, что мы делаем большую и сложную систему, соответственно по любому пуку проджект овнера вносить любые изменения довольно сложно, so умные люди придумали \*небольшую\* схемку как вообще с этим работать:
![[pictures/раз_хуйня.png]]
![[pictures/два_хуйня.png]]
![[pictures/три_хуйня.png]]
//Вопрос гроб бля, вот краткое описание:
Каждый шаг документируется в лог-журнале
1. Запрос проджект овнера
	1. ему опять чето не нравится и он хочет фичей новых
	2. Он вносит свой Change Request в Change Log Entry
2. Комитет по изменениям (ПМ + **анал**итики) принимает решение надо или не надо оно нам
	1. ПМ определяет техническую необходимость
	2. ПМ определяет осуществимость изменений
	3. **Анал**итики анализируют стоимость и преимущества для пользователя
	4. На этом шаге формируются документы/артефакты:
		1. От ПМа "Change Technical Feasibility"
		2. От **анал**итиков  - "Change Cost and Benefits"
3. Проджект менеджер подтверждает
	-  ![[pictures/approved_knuckles.png]]
4. Инженеры реализуют
5. Проверка и закрытие реализации, формальное утверждение
## 34. Системы контроля версий. Одновременная модификация файлов.

## 35. Subversion‌. Архитектура системы и репозиторий.

## 36. Subversion‌: Основной цикл разработчика. Команды.

## 37. Subversion‌: Конфликты. Слияние изменений.

## 38. GIT: Архитектура и команды.

## 39. GIT: Организация ветвей репозитория.

## 40. GIT: Плагин git-flow.

## 41. Системы автоматической сборки: предпосылки появления.

## 42. Системы сборки: Make и Makefile (РАСПРАВА).

## 44. Системы сборки: Ant-ivy.

## 45. Системы сборки: Maven. POM. Репозитории и зависимости.

## 46. Maven: Структура проекта. GAV.

## 47. Maven: Зависимости. Жизненный цикл сборки. Плагины.

## 48. Системы сборки: Gradle. Преимущества и файл сборки.

## 49. Системы сборки: GNU autotools. Создание конфигурации проекта.

## 50. Системы сборки: GNU autotools
## 51. Сервера сборки/непрерывной интеграции.

## 52. Основные понятия тестирования. Цели тестирования.

## Основные понятния:

1. Mistake -- ошибка разработчика. Человеческое деяние, которое в конечном итоге привело к получению неверного результата. В широком смысле отклонение от истины или правил. 
2. Fault -- дефект, изъян, Неверный шаг в алгоритме (или неверное определение данных) в компьютерной программе. Следствие ошибки, потенциальная причина неисправности. 
3. Failure -- неисправность, отказ или сбой -- наблюдаемое проявление дефекта, в том числе, крах или падение программы. невозможность выполнить с использованием программы задачу, получить
4. Error -- невозможность выполнить с использованием программы задачу, получить верный результат.

## Цели тестирования:

1. Обнаружение дефектов. 
2. Повышение уверенности в уровне качества. 
3. Предоставление информации для принятия решений. 
4. Предотвращение дефектов.
5. Увеличение **пользовательского** доверия в том, что программа функционирует корректно во всех необходимых обстоятельствах. (то есть мы показываем что ошибки были *найдены и исправлены*)

## 53. Понятия полного тестового покрытия и его достижимости. Пример.

Понятие "тестовое покрытие" включает в себя то, насколько код приложения покрыт тестами, которые могут находить известные и потенциальные дефекты. Полное тестовое покрытие подразумевает покрытие тестами всего кода и всех возможных вариантов развития событий, возможных в данном коде. Полное тестовое покрытие, если и достижимо, то ценой очень больших затрат.
## Пример: Умножение двух чисел

В качестве иллюстрации приведена функция умножения двух чисел. Если оба множителя имеют степени $2^{32}$, то для полного покрытия необходимо провести $2^{64}$ операций. Предположим, что 1 операция умножения выполняется за 1 такт процессора. Тогда, учитывая, что $2^{10} \approx 10^3$, однопоточное приложение на 3Гц ЦПУ будет проводить тестирование функции в течение примерно 181,5 лет. $$
	\frac{2^{32} \cdot 2^{32}}{3 \cdot 10^9} = \frac{2^{10} \cdot 2^{10} \cdot 2^{10} \cdot 2^{34}}{3 \cdot 10^3 \cdot 10^3 \cdot 10^3} \approx \frac{2^{34}}{3} \approx \frac{5723784000}{365 \cdot 24 \cdot 60 \cdot 60} = 181,5 \text{ [лет]}
	$$

## 54. Статическое и динамическое тестирование.

![[pictures/vchart.png]]

Статическое тестирование способствует раннему нахождению дефектов, что экономит время и средства. На рынке разработки существует мнение, что по мере перехода от одной фазы разработки к другой, стоимость исправления дефекта растет с фактором 10.

1. **Статическое (рецензирование):**
	1. Не включает выполнения кода.
	2. Ручное, автоматизированное.
	3. Неформальное, сквозной контроль, инспекция.
2. **Динамическое:**
	1. Запуск модулей, групп модулей, всей системы.
	2. После появления первого кода (при TDD — иногда перед!)

## 55. Автоматизация тестов и ручное тестирование.

### **Автоматические тесты**:
1. **Регрессионное тестирование**
	- Это вид тестирования, который заключается в повторном запуске старых тестов после внесения изменений в программу.
	- Цель: проверить, не повлияли ли изменения на работу программы и не появились ли новые ошибки.
2. **Повторение тестового сценария**
	- Необходимо обеспечить однозначное повторение тестовых сценариев.
	- Внутри ПО должно отсутствовать вариативность в поведении: одинаковые входные данные должны всегда давать одинаковые выходные данные.
3. **Приёмочное тестирование**
	- Тестирование, проводимое для подтверждения соответствия продукта требованиям и стандартам.
	- Автоматизация тестов может ускорить процесс, но требует разработки сложных программ для формирования тестовых сценариев.
4. **Сокращение ручного труда?**
	- Автоматизация тестов часто рассматривается как способ сокращения ручного труда.
	- Однако в простых задачах может оказаться дешевле нанять низкоквалифицированный персонал, чем писать сложные тестовые программы.
5. **Проверка одного приложения в разных окружениях (тестирование совместимости)**
	- Необходимость тестировать приложение в различных средах (например, на разных операционных системах или браузерах) увеличивает сложность процесса.
	- Чем меньше изначальных функциональных тестов, тем проще и быстрее будет выполнение таких тестов.
###  **Статические тесты** (скопировано из пред. пункта)
1. Неформальное, сквозной контроль, инспекция.

## 56. Источники данных для тестирования. Роли и деятельности в тестировании.

## 57. Понятие тестового случая и сценария.

## 58. Выбор тестового покрытия и количества тестов.

## 59. Модульное тестирование. JUnit 4.

## 60. Интеграционное тестирование. Стратегии интеграции.

## 61. Функциональное тестирование. Selenium.

## 62. Техники статического тестирования. Статический анализ кода.

## 63. Тестирование системы в целом. Системное тестирование. Тестирование производительности.

## 64. Тестирование системы в целом. Альфа- и бета- тестирование.

## 65. Аспекты быстродействия системы. Влияние средств измерения на результаты.

## 66. Ключевые характеристики производительности.

## 67. Нисходящий метод поиска узких мест.






## 68. Пирамида памяти и ее влияние на производительность.

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeDHDpgQyPJC-goIXf4119ttwpBtHVYS0SbgVmlBbVM3Kx2zpEN0G5LJylICIhR7hZVF1POZq_5VKZnm2wZIBHv7uAJiRObivZHMDNXYPNGIrUoCB_PFvk-FLd18L5o4vRUvAkFQDf8ThW3b7V4_bhZhMOR?key=1pD2kcEQ8Lrk26WoBNVmmQ)

Сверху пирамиды - самая дорогая память с наименьшим объемом (***CPU***) 

Внизу - самая дорогая память с наибольшим объемом (SSD, HDD. Маг. Ленты)

Чем ниже память в пирамиде, тем дороже по времени обходится обращение к ней. Например обращение к основной памяти (в середине пирамиды) может занимать в сотни раз больше времени чем к CPU и кэшам

Минимизация количества обращений к нижним уровням пирамиды во много раз повышает производительность - иногда в сотни или миллионы раз.

Постоянное обращение к нижним частям пирамиды может давать существенную задержку в работе ПО.
Учет архитектуры ЭВМ позволяет сделать разрабатываемые  программы существенно (на несколько порядков быстрее)

## 69. Мониторинг производительности: процессы.

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfWzyVA8B-i_mxti0R2_MACyixsflhrN9evkBSsa87wjcfHil_ZIzu2hR-M7CuiVWX8R1gl5Put4v3iQ4Urn5Xl7Dcx1mhAlpWqF_8llajSGLFA0-lZPxFunoNTLXqFWBQMudBjnRNb2hNV0HNxedi7YQlW?key=1pD2kcEQ8Lrk26WoBNVmmQ)

## 70. Мониторинг производительности: виртуальная память.

## 71. Мониторинг производительности: буферизированный файловый ввод-вывод.

## 72. Мониторинг производительности: Windows и Linux.

## 73. Системный анализ Linux "за 60 секунд".

## 74. Создание тестовой нагрузки и нагрузчики.

## 75. Профилирование приложений. Основные подходы.

## 76. Компромиссы (trade-offs) в производительности.

## 77. Рецепты повышения производительности при высоком %SYS.

## 78. Рецепты повышения производительности при высоком %IO wait.

## 79. Рецепты повышения производительности при высоком %Idle.

## 80. Рецепты повышения производительности при высоком %User.
