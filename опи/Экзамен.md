## 1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ. 

Жизненный цикл ПО: 

- Разработка требований (заказчик, программисты)
- Анализ
- Проектирование архитектуры
- Разработка
- Тестирование
- Внедрение в эксплуатацию
- Эксплуатация (багфиксы, поддержка пользователей, обновления)
- Вывод из эксплуатации
	- Сохранность накопленных файлов
	- Миграция на новое ПО

Группы ЖЦ ПО: 

1. Процесс согласования (2)
2. Процесс организационного обеспечения (5)
3. Процессы проекта (7)
4. Технологические процессы (11)
5. Процесс реализации программного средства (7)
6. Процесс поддержки ПС (8)
7. Процесс повторного использования ПС

## 2. Модели ЖЦ (последовательная, инкрементная, эволюционная)

#### Последовательная 
-  A.k.a. однократная, waterfall
-  Определены все требования, один этап разработки
-  Один последовательный проход
-  Получившиеся результаты окончательны и, как правило, не подлежат пересмотру

#### Инкрементнеая
- Определены не все требования
- Разрабатывается прототип, который с течением времени развивается

###### Сравнение стратегий
|Стратегия разработки|В начале процесса определены все требования?|Множество циклов разработки?|Промежуточное ПО распространяется?|
|---|----|----|---|
|Последовательная|Да|Нет|Нет|
|Инкрементная|Да|Да|Maybe|
|Эволюционная|Нет|Да|Да|

## 3. Водопадная (каскадная) модель
![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcgj2PIgMq0q2Jhji2fL1A6NOf8alPM-GHervvvjrMAcLqkf2DINsZiu5lkalI72crfZSFaSRiID0-zVDM9NfU0Zq0DtSb2a7l_FH7RBAkbzG54EILaX0k9zfK2l-7E2WpghTykpf4mc_9QPT-h-3xhkCQY?key=1pD2kcEQ8Lrk26WoBNVmmQ)


- Разработана в 60-х
- Описана ройсом в 70-х

**Суть** в том, что есть 7 фаз раработки ПО, которые идут друг за другом только, и только в этом порядке и между ними есть итерации:

1. Сбор требований к системе
2. Сбор требований к ПО
3. Анализ требований
4. Проектирование дизайна ПО
5. Кодирование
6. Тестирование
7. Эксплуатация

- Можно откатиться к предыдущей фазе, но это сложно и не особо предусмотрено, так как потенциально это может привести к двухкратному росту сроков и стоимости разработки

|Плюсы|Минусы|
|---|---|
|Хорошие показатели по срокам разработки и надежности при решении отдельных задач|Неприменимость к большим и сложным проектам из-за невозможности принять изменения требований к системе в течение длительного проектирования|
|Автоматизация отдельных несвязных задач|Позднее тестирование|

## 4. Методология Ройса
Водопад, но с дополнительными шагами
 
 1. Предварительный дизайн - между программными требованиями и анализом
	 - Программисты и аналитики не допускаются
	 - На этом этапе предполагается спроектировать, определить и создать модель обработки данных, а так же создать документ-обзор системы
2. Написание документации для всей системы
	- Требования к системе
	- Спецификация предварительного дизайна
	- Спецификация дизайна интерфейсов
	- Финальная спецификация дизайна системы
	- План тестирования
	- Инструкция пользовательской эксплуатации
3. Параллельная разработка тестовой версии с укороченным временем разработки для анализа характеристик ПО
4. Тестирование с привлечением независимых экспертов
	- Наиболее рисковая фаза с точки зрения денег и сроков
5. Несколько этапов подключения пользователей
	- Предварительный
	- Критический
	- Финальный просмотр


## 5. Традиционная V-chart model J. Munson, B.Boehm
![[pictures/vchart.png]]
Та же последовательность действий, что и в водопаде, но ее изогнули в форме V, сопоставив с почти каждой фазой из каскадной модели соответствующее тестирования

Определяются следующие этапы:
1. Сбор требований к системе $\leftrightarrow$ Использование и поддержка  
2. Сбор требований к ПО $\leftrightarrow$ Установка системы в конечном окружении  
3. Дизайн продукта $\leftrightarrow$ Приемочное тестирование  
4. Детализация дизайна $\leftrightarrow$ Системное и интеграционное тестирование  
5. Кодирование $\leftrightarrow$ Юнит-тестирование  

## 6. Многопроходная модель (Incremental model)
**Частный случай V-chart модели**

Параллельная разработка частей продукта, а в последствии интегрирование воедино
- На этапе разработки происходит вместо одного этапа несколько, каждый включает в себя
	- Детальное проектирование
	- Кодирование
	- Интеграция протот

Снижение стоимости внесения изменений

Возможность использования частично разработанной системы

Имеет тенденцию к устареванию, деградации
- Соответственно требует рефакторинга с течением времени

При параллельной разработке несколькими командами требует стабильного API

Из-за высокой скорости изменений поддерживать документацию в больших проектах становится достаточно сложно

Из-за всех факторов, сложно оценивать стоимость разработки ПО

## 7. Модель прототипирования (80-е)
![[pictures/Прототипирование.png]]  
#### Суть
##### Фазы:
1. Планирование
- Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
- Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение

2. Пользовательское проектирование
- Пользователи взаимодействуют с системными аналитиками 
- Разрабатывают модели и прототипы
- Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованием

3. Конструирование
- На этом этапе происходит разработка программ и приложений
- Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов

4. Переключение
- Конверсия данных
- Тестирование
- Переход на новую систему
- Тренировку пользователей

##### Позволяет обеспечить:
- Быстроту продвижения програмнного продукта на рынок
- Интерфейс, устраивающий пользователя
-  Легкую адаптируемость проекта к изменяющимся требованиям
- Простоту развития функциональности системы

## 8. RAD методология
![[pictures/RAD.png]]

RAD - Rapid Application Dev Model - Быстрая разработка приложение

Порождена IBM в 80-х, обнародована в 1991
Разновидность инкрементной модели
Пользователь принимает непосредственное участие в процессе разработки
Временные рамки одного цикла **жестко** ограничены

#### Суть

##### Фазы
1. Планирование
- Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
-  Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение

2. Пользовательское проектирование
- Пользователи взаимодействуют с системными аналитиками
- Разрабатывают модели и прототипы
- Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованиям

3. Конструирование
- На этом этапе происходит разработка программ и приложений 
- Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов

4. Переключение
- Конверсию данных
- Тестирование
- Переход на новую систему
- Тренировку пользователей

##### Позволяет обеспечить
- Быстроту продвижения програмнного продукта на рынок
- Интерфейс, устраивающий пользователя
- Легкую адаптируемость проекта к изменяющимся требованиям
- Простоту развития функциональности системы

## 9. Спиральная модель
По сути - это совмещение прототипной модели + куча тестирования из V-chart модели

Особое внимание уделяется управлению рисками
- Вследствие, специфический анализ на каждой итерации

Каждый виток спирали - одна фаза разработки продукта, которая предназначена для разработки очередной версии ПО или прототипа

На разных фазах спирали разрабатываются основные концепции ПО

|Достоинства|Недостатки|
|---|---|
|Изменения - неотъемлимая часть разработки|Разработка может оказаться затратной|
|Особое внимание уделяется управлению рисками|Не подходит для маленьких проектов|


## 10. UML Диаграммы: Структурные и поведенческие

Основное значение - графическое представление различных аспектов разработки ПО

### UML
Графический язык моделирования общего назначения
Предназначен для:
- Спецификации
- Визуализации
- Проектированию и документированию артефактов

UML Диаграммы делятся на

##### Структурные
- Доменные модели
- Диаграммы развертывания

Нужны для 
- Статического описания системы
- Демонстрации архитектуры, конфигурации, специфических элементов предметной области

##### Поведенческие
- Диаграммы прецедентов использования 
	- Use-case диаграммы
	- Описывают высокоуровневые требования к системе
- Диаграммы последовательностей
	- Описывают последовательность алгоритма
- Диаграммы состояний
	- Описывают состояние системы

Представляют собой динамическую картину действий, происходящих в системе

##  11. UML: Use-case модель 
Поведенческая диаграмма

Отображает динамическое поведение в UML

Моделирует функциональность системы с использованием участников/прецедентов/других важнейших объектов

**Actors** (акторы) - люди/организации, которые работают под определенными ролями внутри системы

**Use-case** - прецедент использования

**Association** - ассоциация, использование

**Include** - включение
- Организует иерархию прецедентов и позволяет включать одну общую деятельность в несколько Use-Case'ов

**Extend** - точка расширения функционала
- Указывает расширение от базового функционала

**Generalization** - обобщение
**System Boundary** - границы системы

## 12. UML: Диаграмма классов

Структурная диаграмма

- Представляет модель **статической структуры** программной системы
- Используется в **ООП** — терминология классов
- Отражает:
	- Взаимосвязи между сущностями предметной области (f.e. объекты и подсистемы)
	- Внутреннюю структуру объектов (f.e. поля, методы)
	- Типы отношений (наследование, реализация интерфейсов)
- Не включает информацию о **временных аспектах**
- Показывает **реализованную предметную область** в первом приближении

## 13. UML: Диаграмма последовательностей

Поведенческая диаграмма

- A.k.a. диаграмма конечных автоматов
- Отображает модель **конечных автоматов**
- Представляет собой набор **состояний и условий переходов** между ними

## 14. UML: Диаграмма размещения

Структурная диаграмма

- Отображает **физическую архитектуру** размещения ПО
- Описывает процесс **развертывания артефактов** по узлам

f.e.:

- Диаграмма с изображением серверной машины, на которой:
	- Крутится веб-сервер
	- Веб-сервер запускает JVM
	- В JVM работает микросервис
	- Отдельно изображена пользовательская машина с браузером

## 15. *UP методологии (90-е). RUP: основы процесса

- RUP — частный пример \*UP, основан на OOSE + OMT + метод Буча
- Инкрементно-эволюционный процесс
- Разработка разбита на **4 фазы**:
	1. Inception / Начало
	2. Elaboration / Проектирование
	3. Construction / Построение
	4. Transition / Внедрение
- Каждая фаза заканчивается **вехой** (milestone)
- Все роли явно описаны (около 30)
	- Роль = группа обязанностей одного участника
	- У каждой роли есть:
		- Набор деятельностей
		- Входы/выходы в виде артефактов (диаграммы, документы, код)
- Все процессы в RUP связаны между собой и **подробно описаны**
- Сам RUP — это HTML-энциклопедия, все элементы связаны гиперссылками

## 16. RUP: Фаза «Начало»

**Цели:**

1. Определить границы/области применения проекта
2. Описать основные сценарии использования
3. Предложить технологическое решение
4. Рассчитать стоимость и составить график работ
5. Оценить риски
6. Подготовить окружение

**Веха: Lifecycle Objectives**

- Оценка сроков
- Первоначальная стоимость
- Требования
- Приоритеты
- Технологии
- Стратегии смягчения рисков

## 17. RUP: Фаза «Проектирование»

**Цели:**

1. Финализировать архитектуру системы
2. Разработать архитектурные прототипы
3. Проверить стабильность архитектуры, планов и рисков

**Веха: Lifecycle Architecture**

- Требования, архитектура стабильны?
- Есть критерии тестирования прототипов?
- Тестирование прошло успешно?
- Планы разработки приемлемы по стоимости?
- Расходы соответствуют бюджету?
- Проект подтвержден всеми заинтересованными сторонами?

## 18. RUP: Фаза «Построение»

**Цели:**

1. Эффективно реализовать ПО
2. Провести итерации: анализ → проектирование → код → тест
3. Создать релизы (альфа, бета…)
4. Подготовить продукт к развертыванию

**Веха: Initial Operational Capability**

- Продукт стабилен для передачи заказчику?
- Готова принимающая сторона?
- Стоимость соответствует ожиданиям?

## 19. RUP: Фаза «Внедрение»

**Цели:**

1. Развернуть систему и БД на целевой платформе
2. Обучить пользователей
3. Запустить маркетинг, продажи
4. Отладить сбои, выкатить хотфиксы
5. Убедиться в самодостаточности пользователей
6. Провести анализ соответствия ожиданиям

**Веха: Release**

- Пользователи удовлетворены?
- Финальная стоимость приемлема?

## 20. Манифест Agile (2001)

4 ценности:
1. Люди и взаимодействие > процессов и инструментов
2. Работающий продукт > исчерпывающей документации
3. Сотрудничество с заказчиком > согласованного контракта
4. Готовность к изменениям > следования плану

## 21. Scrum

- **Бэклог** — основной артефакт
	- Продукт-бэклог: бизнес-требования
	- Спринт-бэклог: технические детали
- **Спринт** — итерация 1–4 недели
	- В конце — демонстрация заказчику
	- Каждые несколько спринтов — **ретроспектива**
	- Каждый день — **дейлик** (скрам-митинг)
		- Что сделано
		- Что планируется
- **Команда**: 3–10 человек
- **Роли**:
	- Продакт овнер
		- Формирует приоритеты бэклога
	- Скрам-мастер
		- Организует скрам-митинги
		- Планирует спринты
		- Разрешает конфликты

**Плюсы:**

- Простота
- Минимум бюрократии
- Максимум ценности

## 22. Disciplined Agile 2.X (2013)

- Гибрид RUP + Scrum
- Использует **инкрементальную модель** со спринтами

#### Из RUP:
- Фазы: Начало / Построение / Внедрение
- Описание ролей

#### Из Scrum:
- Спринты

### Новое в DAD:
- Архитектурное управление
- Переиспользование кода
- Управление персоналом
- Постоянное улучшение процесса

## 23. Требования. Иерархия требований

- Требование = описание того, что должно быть реализовано
- Не говорит **как** реализовать
- Не должно быть разночтений
- Документируются в **SRS**

### Иерархия:

1. Потребности (пользователь)
	- "Мне нужна сковорода, на которой не будет пригорать"
2. Функции (аналитик)
	- "Антипригарное покрытие, термоизолированная ручка"
3. Требования к ПО
	- "Диаметр 25см, бортики 5см, алюминиевый сплав АК7П"

## 24. Свойства и типы требований (FURPS+)

Используется в RUP

### Свойства требований:

- Корректность
- Однозначность
- Полнота
- Непротиворечивость
- Приоритизация
- Проверяемость
- Модифицируемость
- Отслеживаемость

### Типы требований:

- **F** — Functional (функциональные)
- **U** — Usability (удобство использования)
- **R** — Reliability (надежность)
- **P** — Performance (производительность)
- **S** — Supportability (поддержка)
- **+** — прочее:
	- Ограничения проектирования
	- Интерфейсы
	- Физические требования


## 25. Формулирование требований. Функциональные требования

Формат записи:
`<id> <система> должна / shall <требование>`

Функциональные требования — описывают **что система должна делать**.
### Примеры:
- Feature sets
	- Наборы функциональности
- Capabilities
	- Возможности системы
- Security
	- Требования к безопасности

## 26. Требования к удобству использования и надежности (Usability & Reliability)

### Usability (удобство использования)

1. Human Factors
	- Учет особенностей пользователей
		- e.g. плохое зрение, слух
2. Aesthetics
	- Эстетические требования (e.g. брендбук, оформление интерфейса)
3. Consistency in UI
	- Согласованность элементов пользовательского интерфейса
4. Online и context-sensitive help
	- Требования к справке:
		- Онлайн-доступ
		- Контекстная подсказка
5. Wizards и Agents
	- Программы, повышающие удобство:
		- Wizard — пошаговые мастера установки (куда ставить, ярлык, uninstaller)
		-  Agents — TODO: не понял что это, нужно уточнить 
6. User Documentation
	- Требования к документации для конечных пользователей
7. Training Materials
	- Учебные материалы (видео, презентации, интерактивные мануалы)

### Reliability (надежность)

1. Frequency and severity of failure
	- Частота и серьезность отказов
2. Recoverability
	- Способность системы **восстанавливаться** в случае отказа
3. Predictability
	- Предсказуемость поведения системы
4. Availability
	- Готовность к выполнению задач в нужный момент времени
5. Accuracy
	- Точность выполнения операций
6. MTBF (Mean Time Between Failures)
	- Среднее время между отказами
## 27. Требования к производительности и поддерживаемости.


Производительность определяются
- Speed — скорость решения задач
- Efficiency — эффективность
- Availability — готовность системы к решению задач
- Throughput — пропускная способность
- Response time — время отклика
- Recovery time — время восстановления
- Resource usage — использование системных (и других) ресурсов
Поддерживаемость определяются
- Extensibility — расширяемость
- Adaptability — адаптируемость
- Maintainability — поддерживаемость
- Compatibility — совместимость
- Configurability — способность задавать конкретную конфигурацию
- Serviceability — возможность проведения профилактики и обслуживания
- Installability — требования к установке на разные системы
- Localizability — локализуемость для разных языков и географических регионов.
## 28. Атрибуты требований.

1. Приоритет - MoSCoW
	1. MUST have
		- Фундаментальные для системы требования
	2. Should have
		- Важные
	3. Could have
		- Потенциально возможные, улучшающие
		- e.g. пользовательское соглашение
	4. Won't have
		- Возможно в следующей версии
2. Статус
	1. Предложенные
	2. Одобренные
	3. Отклоненные
	4. Включенные
3. Трудоемкость
	1. Человеко-часы
	2. Функциональные точки
	3. Use-case points
	4. Попугаи
		1. Один попуг - это некое эталонное функциональное требование, которое выполняется средним человеком в команде
		2. Время, потраченное на данную работу принимается за одного попуга
		3. Все остальные требования отсчитываются относительно эталонного попугая
4. Риск
5. Стабильность
	1. Высокая
	2. Средняя
	3. Низкая
6. Целевая версия
	1. "Когда включим в продукт?"

## 29. Описание прецедента.

Прецеденты/cases могут быть описаны в виде сценариев/user story

В дальнейшем разработчики зачастую анализируют не требования, а сценарии

| Прецедент             | Описание                                           |
| --------------------- | -------------------------------------------------- |
| ID                    | Номер                                              |
| Краткое описание      | Пользователь хочет просмотреть новостную статью    |
| Главные акторы        | Пользователь                                       |
| Второстепенные акторы | Опциональны (в данном случае нет)                  |
| Предусловия           | Пользователь увидел интересующую статью            |
| Основной поток        | Пользователь переходит на одну из возможных статей |
| Альтернативный поток  | Опционален (отсутствует в данном случае)           |
| Постусловия           | Система показывает пользователю новостную статью   |

## 30. Риски. Типы Рисков.


Риск - это
 - Потенциально опасный для проекта фактор
 - Влияние неопределенности на цели
 - Сочетание вероятности события и его (негативных) последствий

Типы рисков:
1. Прямые
	1. Можем управлять, контролировать риск
2. Непрямые
    -  не можем((

Типы рисков:
1. Ресурсные
	- Организационные, финансовые, люди, время
	- Управляемые риски, так как возможно изменение выделяемых ресурсов
2. Бизнес-риски
    - Конкуренция, подрядчики, убыточность решения
    - Сложно поддается управлению со стороны разработчиков
3. Технические риски
    - Компетенции разработчиков в применяемых технологиях
4. Политические риски
	 - Сферы влияния менеджеров
	 - 
5. Форс-мажор
    - [фр.](https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%B0%D0%BD%D1%86%D1%83%D0%B7%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Французский язык") force majeure — «_высшая сила_»
    - e.g. стихийные бедствия, война, изменение законодательства)) и т.д.


## 31. Управления рисками. Деятельности, связанные с оценкой.

- Оценка (assesment) риска
	 - Идентификация риска
		 - ![[pictures/Дерево идентификации рисков.png]]
	 - Анализ риска
		 - Можно по разному анализировать (стоимостной, сетевой, качественных факторов), но есть два основных параметра риска:
			 1. Вероятность риска
			 2. Масштаб (магнитуда) потерь
		 - Задаются в разных величинах и очень субъективны
	 - Приоритизация риска
		 - После анализа необходимо вычислить экспозицию риска (Risk Exposure): $RE=Prob(UO)*Loss(UO)$, то есть произведение вероятности наступления риска на величины денежных потерь
		 - После этого состается документ "Топ-10 рисков"
			 - Этот док необходимо постоянно обновлять по мере продвижения разработки
## 32. Управления рисками. Деятельности, связанные с контролем и управлением.

Контроль и управление риском:
- Планирование управления/реакции на риски
	- Реорганизация проекта чтобы избежать наступления рисков
		- e.g. повышение квалификации сотрудников/нанимание новых образованных людей
	- Перенос риска
		- на кого-то))
		- e.g. обвинить клиента в недостаточном финансировании и сказать "нет денег - нет работ" и теперь уже риск того, что ПО не выйдет висит на клиенте 
	- Сокращение вероятности риска
	- Прием риска
		- Продолжать жить с риском, постоянно осуществляя мониторинг
- Мониторинг рисков
	- Контроль топ-10 рисков
	- Переоценка рисков
	- Автоматизированные системы
		- e.g. числовые параметры, сбор данных с жиры и VCS (git)
- Разрешения неопределенностей, связанных с рисками
	- Прототипирование системы
	- Моделирование и симуляция
	- Различные индикаторы
	- Аналитическая работа
	- Подбор персонала
## 33. Изменение. Общая модель управления изменениями.

**Изменение** - контролируемое, журналируемое обновление системы

Атрибуты изменения:
1. ID
2. Дата
3. Ответственный
4. Описание
5. Журнал изменений
6. т.д.

Управлению изменениями подлежат:
1. Требование новой функциональности
2. Нефункциональное требование
3. Исправление дефектов
4. Другие артефакты архитектуры, анализа, дизайна
5. т.д.

Из-за того, что мы делаем большую и сложную систему, соответственно по любому пуку проджект овнера вносить любые изменения довольно сложно, so умные люди придумали \*небольшую\* схемку как вообще с этим работать:
![[pictures/раз_хуйня.png]]
![[pictures/два_хуйня.png]]
![[pictures/три_хуйня.png]]
//Вопрос гроб бля, вот краткое описание:
Каждый шаг документируется в лог-журнале
1. Запрос проджект овнера
	1. ему опять чето не нравится и он хочет фичей новых
	2. Он вносит свой Change Request в Change Log Entry
2. Комитет по изменениям (ПМ + **анал**итики) принимает решение надо или не надо оно нам
	1. ПМ определяет техническую необходимость
	2. ПМ определяет осуществимость изменений
	3. **Анал**итики анализируют стоимость и преимущества для пользователя
	4. На этом шаге формируются документы/артефакты:
		1. От ПМа "Change Technical Feasibility"
		2. От **анал**итиков  - "Change Cost and Benefits"
3. Проджект менеджер подтверждает
	-  ![[pictures/approved_knuckles.png]]
4. Инженеры реализуют
5. Проверка и закрытие реализации, формальное утверждение
## 34. Системы контроля версий. Одновременная модификация файлов.
- Управляют изменениями в программном коде
- поддерживают групповую работу
- основные типы
  - на основе файловой системы (данный подход является устаревшим)
  - централизованная, с единым репозиторием (subversion)
  - распределённая. Центральный репозиторий из которого пользователи скачивают данные на локальный репозиторий (git)
- примеры СКВ: SCCS RCS ClearCase CVS SVN MS Visual Source Safe Mercurial git Bazaar
Одновременная модификация файлов:
- Главной проблемой при работе с СКВ было конфликты между версиями, подходы к решению этой проблемы:
  - Lock-modify-unlock:
    - При работе одного пользователя с файлом он блокируется для других.  
    -  Другие пользователи не могут модифицировать файл.  
    - Недостатки:  
    - Замедляет работу команды.  
    - Пользователи вынуждены либо бездействовать, либо переключаться на другие задачи.  
    - Характерен для СКВ, связанных с общей файловой системой.
  - Copy-modify-merge:
    - Каждый пользователь копирует себе весь репозиторий и работает с ним.  
    - Изменения всех пользователей сливаются (merge).  
    - Основная проблема: слияние рабочих копий.  
    - Пример: два разработчика изменяют один и тот же код разными способами.  
    - При попытке сохранить изменения второй разработчик сталкивается с конфликтом и вынужден его разрешать (часто совместно с первым разработчиком).

## 35. Subversion‌. Архитектура системы и репозиторий

![[svn_scheme.png.png]]

Subversion repository может быть реализован двумя способами:
- **Berkeley DB** (база данных)
- **FSFS** (файловая система, упрощённый вариант)
Компоненты доступа к репозиторию:
- Демон svnserve:
	- Получает команды пользователей
	- Выполняет изменения в репозитории
-  **Альтернативный доступ**:
    - Через сервер Apache с модулями
    - Реализует аналогичную svnserve логику
    
Протоколы удалённого доступа:
- `svn://`
- `svn+https://` 
- `ssh+svn://`
- 
Клиент SVN выполняет две ключевые функции:
- Передача данных между репозиторием и клиентом
-  Управление локальной копией файлов:
   - Синхронизация выбранной версии с локальными файлами
   - Контроль изменений разработчика
Репозиторий - папка ебать????????????


![[repo.png]]
В **SVN** каждая фиксация изменений (`svn commit`), пришедшая в репозиторий, повышает его версию на 1. **Ревизия репозитория** — это всегда целое число, уникально характеризующее набор файлов на определённый момент времени

Организация файлов в репозитории обычно выглядит следующим образом: существуют каталоги проектов (например, `poked` и `train-place`), внутри которых расположены директории для работы с разными версиями проекта.

В каталоге **trunk** ведётся основная разработка. Сюда разработчики ежедневно вносят изменения, оформленные как целостные наборы (как с точки зрения файлов, так и их логического содержания).

стабильные копии проекта создаются на основе `trunk` и копируются в дополнительные каталоги:
- **branch** — для ветвления разработки,
- **tags** — функционально целостные изменения

trunk - основная версия разработки
## 36. Subversion‌: Основной цикл разработчика. Команды.
![[develop_cycle.png]]
#реaльно билет в один скрин
## 37. Subversion‌: Конфликты. Слияние изменений.
![[conflicts.png]]

Основная проблема - конфликты содержимого файлов

![[conflicts diff.png]]

в средах разработки обычно есть средства, позволяющие разрешать конфликты. называются diff, пример на слайде

Помимо конфликтов содержимого есть еще конфликты структуры - 
происходят они например когда в репозитории перемещаются файлы, а в локальной рабочей копии в это же файлы вносят изменения.

Слияния:
![[merge.png]]

## 38. GIT: Архитектура и команды.

## 39. GIT: Организация ветвей репозитория.

## 40. GIT: Плагин git-flow.

## 41. Системы автоматической сборки: предпосылки появления.

## 42. Системы сборки: Make и Makefile (РАСПРАВА).

## 44. Системы сборки: Ant-ivy.

## 45. Системы сборки: Maven. POM. Репозитории и зависимости.

## 46. Maven: Структура проекта. GAV.

## 47. Maven: Зависимости. Жизненный цикл сборки. Плагины.

## 48. Системы сборки: Gradle. Преимущества и файл сборки.

## 49. Системы сборки: GNU autotools. Создание конфигурации проекта.

## 50. Системы сборки: GNU autotools
## 51. Сервера сборки/непрерывной интеграции.

## 52. Основные понятия тестирования. Цели тестирования.

### Основные понятния:

1. Mistake -- ошибка разработчика. Человеческое деяние, которое в конечном итоге привело к получению неверного результата. В широком смысле отклонение от истины или правил. 
2. Fault -- дефект, изъян, Неверный шаг в алгоритме (или неверное определение данных) в компьютерной программе. Следствие ошибки, потенциальная причина неисправности. 
3. Failure -- неисправность, отказ или сбой -- наблюдаемое проявление дефекта, в том числе, крах или падение программы. невозможность выполнить с использованием программы задачу, получить
4. Error -- невозможность выполнить с использованием программы задачу, получить верный результат.

### Цели тестирования:

1. Обнаружение дефектов. 
2. Повышение уверенности в уровне качества. 
3. Предоставление информации для принятия решений. 
4. Предотвращение дефектов.
5. Увеличение **пользовательского** доверия в том, что программа функционирует корректно во всех необходимых обстоятельствах. (то есть мы показываем что ошибки были *найдены и исправлены*)

## 53. Понятия полного тестового покрытия и его достижимости. Пример.

Понятие "тестовое покрытие" включает в себя то, насколько код приложения покрыт тестами, которые могут находить известные и потенциальные дефекты. Полное тестовое покрытие подразумевает покрытие тестами всего кода и всех возможных вариантов развития событий, возможных в данном коде. Полное тестовое покрытие, если и достижимо, то ценой очень больших затрат.
### Пример: Умножение двух чисел

В качестве иллюстрации приведена функция умножения двух чисел. Если оба множителя имеют степени $2^{32}$, то для полного покрытия необходимо провести $2^{64}$ операций. Предположим, что 1 операция умножения выполняется за 1 такт процессора. Тогда, учитывая, что $2^{10} \approx 10^3$, однопоточное приложение на 3Гц ЦПУ будет проводить тестирование функции в течение примерно 181,5 лет. $$
	\frac{2^{32} \cdot 2^{32}}{3 \cdot 10^9} = \frac{2^{10} \cdot 2^{10} \cdot 2^{10} \cdot 2^{34}}{3 \cdot 10^3 \cdot 10^3 \cdot 10^3} \approx \frac{2^{34}}{3} \approx \frac{5723784000}{365 \cdot 24 \cdot 60 \cdot 60} = 181,5 \text{ [лет]}
	$$

## 54. Статическое и динамическое тестирование.

![[pictures/vchart.png]]

Статическое тестирование способствует раннему нахождению дефектов, что экономит время и средства. На рынке разработки существует мнение, что по мере перехода от одной фазы разработки к другой, стоимость исправления дефекта растет с фактором 10.

1. **Статическое (рецензирование):**
	1. Не включает выполнения кода.
	2. Ручное, автоматизированное.
	3. Неформальное, сквозной контроль, инспекция.
2. **Динамическое:**
	1. Запуск модулей, групп модулей, всей системы.
	2. После появления первого кода (при TDD — иногда перед!)

## 55. Автоматизация тестов и ручное тестирование.

#### Автоматические тесты:
1. **Регрессионное тестирование**
	- Это вид тестирования, который заключается в повторном запуске старых тестов после внесения изменений в программу.
	- Цель: проверить, не повлияли ли изменения на работу программы и не появились ли новые ошибки.
2. **Повторение тестового сценария**
	- Необходимо обеспечить однозначное повторение тестовых сценариев.
	- Внутри ПО должно отсутствовать вариативность в поведении: одинаковые входные данные должны всегда давать одинаковые выходные данные.
3. **Приёмочное тестирование**
	- Тестирование, проводимое для подтверждения соответствия продукта требованиям и стандартам.
	- Автоматизация тестов может ускорить процесс, но требует разработки сложных программ для формирования тестовых сценариев.
4. **Сокращение ручного труда?**
	- Автоматизация тестов часто рассматривается как способ сокращения ручного труда.
	- Однако в простых задачах может оказаться дешевле нанять низкоквалифицированный персонал, чем писать сложные тестовые программы.
5. **Проверка одного приложения в разных окружениях (тестирование совместимости)**
	- Необходимость тестировать приложение в различных средах (например, на разных операционных системах или браузерах) увеличивает сложность процесса.
	- Чем меньше изначальных функциональных тестов, тем проще и быстрее будет выполнение таких тестов.
####  Статические тесты (скопировано из пред. пункта)
1. Неформальное, сквозной контроль, инспекция.

## 56. Источники данных для тестирования. Роли и деятельности в тестировании.

### Источники данных для тестов

**Методы тестирования:**  
1. **Чёрный ящик**:  
   - Основывается на внешнем поведении системы.  
   - Использует: спецификации, требования, дизайн.  
   - Процесс: подача входных данных и сравнение результатов с эталоном.  

2. **Белый ящик**:  
   - Анализирует внутреннюю структуру кода.  
   - Инструменты: переходы, условия, утверждения, анализ путей (из функций в функцию).  

**Источники данных:**  
- **Опыт разработчика**: позволяет прогнозировать типовые ошибки и минимизировать риски.  
- Из UML диаграмм путь к функции

**Ключевые особенности:**  
- Методы часто комбинируются для повышения эффективности.  
- Цель: достижение полного покрытия функционала и выявление дефектов.

#### Деятельность и роли в тестировании
- **Проектирование тестов:**
    - На основании формальных критериев (по требованиям).
    - На основании знаний предметной области, опыта и экспертизы.
- **Автоматизация тестов:**
    - Знание средств, скриптов.
- **Исполнение тестов:**
    - Нет специальных требований к квалификации.
- **Анализ результатов:**
    - Знания предметной области.

## 57. Понятие тестового случая и сценария.

Тестовый случай (сценарий) состоит из набора входных значений, предусловий выполнения, ожидаемых результатов и постусловий. 

**Ключевые компоненты:**  
1. **Входные данные**:  
   - Данные или управляющие воздействия.  
2. **Условия выполнения**:  
   - Предусловия (состояние системы перед тестом), постусловия (изменения после теста).  
3. **Ожидаемый результат**:  
   - Выходные данные, изменения в системе, побочные эффекты.  
   - Определяется **до** запуска теста (идеал TDD).  
#### Требования к тестовому случаю

- **Повторяемость** :  
    Тестовый случай должен быть повторяемым, т. е. одинаковый набор входных значений и состояний должен приводить к одинаковым выходным значениям или состояниям.
- **Учет состояний :** 
	В тестовом случае должны учитываться состояния внутри ПО (если они есть) и переходы между ними.
	Наличие состояний обычно приводит к расширению тестового покрытия.
#### Автоматизация тестирования

- Для повышения повторяемости теста желательно автоматизировать его проведение.
- Создание автоматизированных тестов особенно важно для регрессионного тестирования:
    - Это позволяет при внесении изменений проводить уже написанные тесты.
    - Проверять, не привели ли новые изменения к появлению дефектов.


| № | Начальное состояние | Ввод                   | Действие системы               | Вывод                     | Конечное состояние     |
|---|---------------------|------------------------|-------------------------------|---------------------------|------------------------|
| 1 | Готов               | Пользователь вставляет карточку | Успешное чтение карточки      | Приглашение "введите pin" | Ожидание pin-кода     |
| 2 | Ожидание pin-кода   | Вводим верный pin-код  | Проверка pin-кода             | Приглашение к выбору транзакции | Ожидание выбора транзакции |
| 3 | Ожидание выбора транзакции | Выбор выдачи 5000 рублей | Проверка баланса, возможности выдачи | Деньги                   | Выдача денег          |
| 4 | Выдача денег        | Пользователь берет деньги и карточку | Завершение выдачи            | Благодарность за использование | Готов               |
## 58. Выбор тестового покрытия и количества тестов.

- Требуется баланс:
  - Много тестов → больше покрытие → качество выше.
  - Меньше тестов → выше скорость разработки → быстрее выход на рынок.

- Необходимо выбрать специфические значения для тестирования:
  - Нельзя же тестировать вечность!
  - Полное покрытие недостижимо.

![[pictures/tests_equivalence.png]]
При анализе эквивалентности тестируемая функция или модуль разбивается на участки, где программа ведет себя одинаково (эквивалентно). Внутри каждого участка формируется свой набор тестовых случаев. Если таких участков относительно немного, это позволяет резко сократить количество тестовых случаев. Отдельные тесты составляются для граничных значений участков.
## 59. Модульное тестирование. JUnit 4.

**Модуль** — это компонент, который необходимо протестировать отдельно от остального программного продукта. Модуль выполняет некую законченную функцию.

*Изоляция модулей* производится ради исключения сторонних воздействий. Она предполагает замену модулей, осуществляющих вызовы **драйверами** (т.е. управляющими тестированием), а подчинённых модулей — **заглушками**. 

**Драйвер** — компонент, вызывающий модули и обеспечивающий последовательность тестирования. 
**Заглушка** ведет себя подобно подчинённому модулю, имеет тот же интерфейс, но гораздо более простую реализацию. При вызове заглушка возвращает заранее определённые значения. 

#### JUnit

- JUnit фреймворк обеспечивает:
  - Аннотации для маркировки метода как теста `@Test`.
  - Аннотации для маркировки действий до и после теста: `@Before`, `@After`, `@BeforeClass`, `@AfterClass`.
  - Методы для проверки (assertion).
  - UI, журнал тестов...

```Java
public class CalculatorTest {
    private Calculator calculator;

    @BeforeClass
    public static void beforeAllTests() {
        System.out.println("Начало тестирования...");
    }
    @Before
    public void setUp() {
        calculator = new Calculator();
        System.out.println("Подготовка перед тестом");
    }
    @Test
    public void testAdd() {
        int result = calculator.add(2, 3);
        Assert.assertEquals(5, result);
    }
    @Test
    public void testSubtract() {
        int result = calculator.subtract(5, 3);
        Assert.assertEquals(2, result);
    }
    @After
    public void tearDown() {
        System.out.println("Тест завершён");
    }
    @AfterClass
    public static void afterAllTests() {
        System.out.println("Все тесты выполнены.");
    }
}
```
## 60. Интеграционное тестирование. Стратегии интеграции.

#### Интеграционное тестирование

- Проверяет интерфейсы и взаимодействие модулей (компонент) или систем:
    - Вызовы API, сообщения между ОО компонентами.
    - Базы данных, пользовательский графический интерфейс.
    - Интерфейсы взаимодействия (сетевые, аппаратные, локальные, ...).
    - Инфраструктурные.
- Может проводиться, когда два компонента разработаны (спроектированы):
    
    - Остальные добавляются по готовности.
#### **Стратегия "сверху вниз"**

- **Описание** : Самая распространенная стратегия разработки, преимущественно используется для бизнес-приложений.
- **Порядок выполнения** :
    1. Проверка бизнес-логики с использованием драйвера и заглушек.
    2. Подключение пользовательского интерфейса (UI), который выполняет запросы к блоку бизнес-логики.
    3. Добавление блоков хранения данных (нижнего уровня).
    4. Проведение тестирования (модульного и интеграционного).
- **Преимущества** : Быстрая демонстрация приложения заказчику.
- **Недостатки** : Требует создания большого количества заглушек, что может привести к избыточному программному обеспечению, используемому только для тестирования.
#### **Стратегия "снизу вверх"**

- **Описание** : Чаще всего применяется для приложений, тесно связанных с аппаратным обеспечением.
- **Порядок выполнения** :
    1. Начинается с блоков нижнего уровня, наиболее взаимодействующих с аппаратной частью.
    2. После подготовки прототипов аппаратных компонентов можно начать тестирование остальных частей приложения.
- **Характеристики** :
    - Цикл разработки аппаратуры обычно длительный и трудоемкий.
    - Компании, работающие с аппаратными продуктами, часто предоставляют тестовые версии своим партнерам до широкого запуска в производство.
# Другие

- **Функциональная (end-to-end)** — по одной функции:
  - Собрали 1 сценарий UI-Логика-БД, добавили еще один такой же.
  
- **Ядро (backbone):**
  - Экран, клавиатура, и системный блок работают с минимальным функционалом.
  - Добавить цвета на экран, мышь, работу колеса прокрутки...

- **Большой взрыв (big bang):**
  - Собрать все вместе и молиться.
## 61. Функциональное тестирование. Selenium.


# Функциональное тестирование

Функциональное тестирование — разновидность интеграционного тестирования, направленная на проверку функций программы в соответствии с сценариями использования. Основные особенности:
- Проверка **бизнес-процессов** целиком, включая взаимодействие разных ролей пользователей.
- Использование **графического интерфейса** как основного элемента управления.
- Возможность проведения тестов **ручным** или **автоматизированным** способом.

## Особенности и ограничения
- Полная автоматизация невозможна: при изменениях в готовом приложении (например, добавлении нового поля в форму) ранее созданные тесты могут требовать корректировки.
- Результаты ручного тестирования позволяют выявить дефекты и сформировать запросы на доработку.

## Инструменты автоматизации
Для ускорения процесса используются утилиты, имитирующие взаимодействие с интерфейсом (ввод данных, щелчки мыши и т.д.). Пример:  
- **Selenium** — плагин для браузера Firefox, позволяющий записывать и сохранять тестовые сценарии в виде программ.
## 62. Техники статического тестирования. Статический анализ кода.
#### Статическое тестирование (рецензирование)

Статическое тестирование — вид анализа ПО (включая код), проводимый **до динамического тестирования**. Цель: выявление дефектов на этапе проектирования или разработки. Отличие от динамического тестирования: фокус на **причины сбоев**, а не на их проявления. (типо сначала смотрим, потом запускаем код)

#### Методы статического тестирования
1. **Рецензирование**  
   - Может быть **ручным** (например, неформальное ревью коллегой) или автоматизированным.  
   - Риск: субъективность оценки или недостаток времени.

2. **Технический анализ**  
   - Проводится под руководством технического лидера или менеджера проекта (management review).  
   - Формализованная процедура с участием команды.

## Стандарты и практики
- Стандарт **IEEE 1028-2008** описывает формальные техники статического тестирования.  
- Методика **walk-through** (сквозной контроль): эксперт проводит аудиторию через код/спецификации, фиксируя недочеты.

Примерами средств статического анализа кода являются **Lint** для C и **FindBugs** для Java. Они строят синтаксическое дерево программы и проводят строгую формальную проверку кода на неопределённое поведение (переменная не инициализирована), нарушение алгоритмов использования библиотеки (`fopen` без `fclose`), сценарии некорректного поведения, разрушение кроссплатформенности и т.п.
## 63. Тестирование системы в целом. Системное тестирование. Тестирование производительности.

**Системное тестирование** — выполняется внутри разработчика без привлечения внешних лиц.  
Тестирование системы в целом происходит по следующим пунктам: (от простого к сложному, сверху вниз)
### CARAT:
  - Capacity — нефункциональные возможности.
  - Accuracy — точность.
  - Response Time — время ответа.
  - Availability — готовность.
  - Throughput — пропускная способность.

**Capacity (нефункциональные возможности)** — возможности, которые система должна предоставлять согласно нефункциональным требованиям. Это характеристики, связанные с заявленным объёмом обрабатываемой информации. 

**Accuracy (точность)** определяет, в основном, точность математических расчётов с заданной константой погрешности. Она может быть критической, например, для систем моделирования физических процессов. В системах реального времени разрабатываемое ПО должно обеспечить заданную точность вычислений в ограниченный промежуток времени.

**Response Time (время ответа)** указывает время ответа системы на запрос пользователя. Оно не должно быть слишком большим, или слишком маленьким. Время ответа в интерактивных системах должно попадать в диапазон от 1 до 5 секунд, при нормальной, определённой в требованиях, нагрузке.

**Availability (готовность)** обычно выражается в коэффициенте готовности:

$$
Availability = \frac{MTBF - MTTR}{MTBF}
$$

где:
- **MTBF (mean time before failure)** — среднее время до отказа,
- **MTTR (mean time to recover)** — среднее время до восстановления.

Например, коэффициент готовности 0.99999 означает, что система может простоять неработоспособной всего 5 минут в год. Для достижения таких результатов необходимо кластерное решение.

**Throughput (пропускная способность)** проверяет, например, сколько клиентских запросов система может обработать за единицу времени.
## 64. Тестирование системы в целом. Альфа- и бета- тестирование.

1. **Системное тестирование** — выполняется внутри разработчика без привлечения внешних лиц.  
2. **Альфа- и бета-тестирование** — пользователи тестируют продукт под контролем разработчиков. 
	1. Альфа-тестирование проводится в среде разработки (разработчиками), 
	2. бета-тестирование — в реальных условиях использования (пользователями). Тестирующие могут выявить непредвиденные сценарии.  
3. **Приёмочное тестирование** — пользователь проверяет систему самостоятельно в своём окружении. На этом этапе решается вопрос выплаты гонорара разработчикам.  

## 65. Аспекты быстродействия системы. Влияние средств измерения на результаты.



## 66. Ключевые характеристики производительности.

## 67. Нисходящий метод поиска узких мест.

## 68. Пирамида памяти и ее влияние на производительность.

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeDHDpgQyPJC-goIXf4119ttwpBtHVYS0SbgVmlBbVM3Kx2zpEN0G5LJylICIhR7hZVF1POZq_5VKZnm2wZIBHv7uAJiRObivZHMDNXYPNGIrUoCB_PFvk-FLd18L5o4vRUvAkFQDf8ThW3b7V4_bhZhMOR?key=1pD2kcEQ8Lrk26WoBNVmmQ)

Сверху пирамиды - самая дорогая память с наименьшим объемом (***CPU***) 

Внизу - самая дорогая память с наибольшим объемом (SSD, HDD. Маг. Ленты)

Чем ниже память в пирамиде, тем дороже по времени обходится обращение к ней. Например обращение к основной памяти (в середине пирамиды) может занимать в сотни раз больше времени чем к CPU и кэшам

Минимизация количества обращений к нижним уровням пирамиды во много раз повышает производительность - иногда в сотни или миллионы раз.

Постоянное обращение к нижним частям пирамиды может давать существенную задержку в работе ПО.
Учет архитектуры ЭВМ позволяет сделать разрабатываемые  программы существенно (на несколько порядков быстрее)

## 69. Мониторинг производительности: процессы.



Системный мониторинг производительности осуществляется при помощи средств ОС, позволяющих получать и анализировать различные параметры OC и запущенных под ее управлением программ.

##### Для мониторинга CPU важно
- Количество процессов на уровне пользователя
- Сколько ресурсов CPU тратит система на эти процессы
- Время простоя процессоров
- параметры ctxt_sw (context switch - переключение контекста)
- interrupts (прерывания)
- load average (средняя загрузка очереди исполнения)

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfWzyVA8B-i_mxti0R2_MACyixsflhrN9evkBSsa87wjcfHil_ZIzu2hR-M7CuiVWX8R1gl5Put4v3iQ4Urn5Xl7Dcx1mhAlpWqF_8llajSGLFA0-lZPxFunoNTLXqFWBQMudBjnRNb2hNV0HNxedi7YQlW?key=1pD2kcEQ8Lrk26WoBNVmmQ)

Схема диспетчеризации процессов CPU в упрощенном виде 

##### Состояния процесса
- Готов к использованию (**Runnable**)
- Находится на исполняющем устройстве (либо на уровне пользователя) либо на уровне OC (ON CPU User/sys)
- Ожидать ввода/вывода, освобождения блокировки и т.п (Wait for smth)
  
  Во время ожидания нет необходимости занимать ресурсы процессора

Пусть у нас есть 2 процесса proc1 и proc2

proc1 -  в процессоре и работает программа пользователя
Раз в 10 мс происходит прерывание от часов (clock interrupt), во время которого ОС наращивает счетчики производительности, проверяет наличие в очереди на исполнение процесса с более высоким приоритетом, чем у текущего, а также проверяет, не исчерпал ли текущий процесс свой квант времени. В нашем случае исполнение proc1 продолжается, так как квант времени не исчерпан и proc2 не является более приоритетным чем зк



## 70. Мониторинг производительности: виртуальная память.

## 71. Мониторинг производительности: буферизированный файловый ввод-вывод.

## 72. Мониторинг производительности: Windows и Linux.

## 73. Системный анализ Linux "за 60 секунд".

## 74. Создание тестовой нагрузки и нагрузчики.

## 75. Профилирование приложений. Основные подходы.

## 76. Компромиссы (trade-offs) в производительности.

## 77. Рецепты повышения производительности при высоком %SYS.

## 78. Рецепты повышения производительности при высоком %IO wait.

## 79. Рецепты повышения производительности при высоком %Idle.

## 80. Рецепты повышения производительности при высоком %User.
